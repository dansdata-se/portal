-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.
CREATE TABLE IF NOT EXISTS internal.events (
  id uuid NOT NULL DEFAULT gen_random_uuid (),
  created_by uuid DEFAULT auth.uid (),
  published boolean NOT NULL DEFAULT FALSE,
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT events_pkey PRIMARY KEY (id),
  CONSTRAINT events_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE SET NULL
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.events OWNER TO postgres;

ALTER TABLE IF EXISTS internal.events ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.events IS 'A collection of event_groups, in turn containing individual event_slots.

"event" is a top-level abstraction, typically symbolizing the entirety of e.g. "Dansbandveckan i Malung".

An event can be split into groups, typically symbolizing e.g. the day, a group of people or something else.
It is up to the event organizer to create appropriate groupings for their specific event.

Each group in the event can be further subdivided into individual "slots". The slot symbolizes an individual
e.g. dance or course session.';

COMMENT ON COLUMN internal.events.published IS 'Whether the given event is published or considered a draft.';

COMMENT ON COLUMN internal.events.created_by IS 'The user who created this event. Mainly intended for diagnostic purposes';

CREATE TRIGGER internal_events_moddatetime
  BEFORE UPDATE ON internal.events
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

CREATE TABLE IF NOT EXISTS internal.event_translations (
  id bigserial,
  event_id uuid NOT NULL,
  language_code text COLLATE pg_catalog."default" NOT NULL,
  title text COLLATE pg_catalog."default" NOT NULL,
  description text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_translations_pkey PRIMARY KEY (id),
  CONSTRAINT event_translations_event_id_language_code_key UNIQUE (event_id, language_code),
  CONSTRAINT event_translations_language_code_fkey FOREIGN KEY (language_code) REFERENCES internal.languages (code) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE RESTRICT,
  CONSTRAINT event_translations_event_id_fkey FOREIGN KEY (event_id) REFERENCES internal.events (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_translations OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_translations ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_translations IS 'Translated texts relating to a given event';

CREATE INDEX IF NOT EXISTS event_translations_title_gin_idx ON internal.event_translations USING GIN (title extensions.gin_trgm_ops);

CREATE TRIGGER internal_event_translations_moddatetime
  BEFORE UPDATE ON internal.event_translations
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

CREATE TABLE IF NOT EXISTS internal.event_organizers (
  id bigserial,
  profile_id uuid NOT NULL,
  event_id uuid NOT NULL,
  created_by uuid DEFAULT auth.uid (),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_organizers_pkey PRIMARY KEY (id),
  CONSTRAINT event_organizers_created_by_fkey FOREIGN KEY (created_by) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE SET NULL,
  CONSTRAINT event_organizers_event_id_fkey FOREIGN KEY (event_id) REFERENCES internal.events (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE,
  CONSTRAINT event_organizers_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES internal.profiles (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_organizers OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_organizers ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_organizers IS 'Determines which profiles are considered organizers of a given event.

Any user that is considered an owner of an organizing profile may edit the event in question.

Example:

"John" creates an event and adds the "Phantastico" band profile as an organizer. Since "Jane" is one of the `profile_owners`
for the "Phantastico" band, she also receives edit access';

COMMENT ON COLUMN internal.event_organizers.created_by IS 'Id of user who added this profile to the given event. Mainly intended for diagnostic purposes';

CREATE TABLE IF NOT EXISTS internal.event_groups (
  id uuid NOT NULL DEFAULT gen_random_uuid (),
  event_id uuid NOT NULL,
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_groups_pkey PRIMARY KEY (id),
  CONSTRAINT event_groups_event_id_fkey FOREIGN KEY (event_id) REFERENCES internal.events (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_groups OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_groups ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_groups IS 'A grouping of event_slots within an event.

"event" is a top-level abstraction, typically symbolizing the entirety of e.g. "Dansbandveckan i Malung".

An event can be split into groups, typically symbolizing e.g. the day, a group of people or something else.
It is up to the event organizer to create appropriate groupings for their specific event.

Each group in the event can be further subdivided into individual "slots". The slot symbolizes an individual
e.g. dance or course session.';

COMMENT ON COLUMN internal.event_groups.event_id IS 'Id of the event this group is a member of.';

CREATE TRIGGER internal_event_groups_moddatetime
  BEFORE UPDATE ON internal.event_groups
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

CREATE TABLE IF NOT EXISTS internal.event_group_translations (
  id bigserial,
  group_id uuid NOT NULL,
  language_code text COLLATE pg_catalog."default" NOT NULL,
  title text COLLATE pg_catalog."default" NOT NULL,
  description text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_group_translations_pkey PRIMARY KEY (id),
  CONSTRAINT event_group_translations_group_id_language_code_key UNIQUE (group_id, language_code),
  CONSTRAINT event_group_translations_language_code_fkey FOREIGN KEY (language_code) REFERENCES internal.languages (code) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE RESTRICT,
  CONSTRAINT event_group_translations_group_id_fkey FOREIGN KEY (group_id) REFERENCES internal.event_groups (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_group_translations OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_group_translations ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_group_translations IS 'Translated texts relating to a given event group';

CREATE TRIGGER internal_event_group_translations_moddatetime
  BEFORE UPDATE ON internal.event_group_translations
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

CREATE TABLE IF NOT EXISTS internal.event_slots (
  id uuid NOT NULL DEFAULT gen_random_uuid (),
  group_id uuid NOT NULL,
  "start" timestamp with time zone NOT NULL CHECK ("start" < "end"),
  "end" timestamp with time zone NOT NULL CHECK ("start" < "end"),
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  created_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_slots_pkey PRIMARY KEY (id),
  CONSTRAINT event_slots_group_id_fkey FOREIGN KEY (group_id) REFERENCES internal.event_groups (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_slots OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_slots ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_slots IS 'An atomic unit within an event, e.g. a single course session or dance.

"event" is a top-level abstraction, typically symbolizing the entirety of e.g. "Dansbandveckan i Malung".

An event can be split into groups, typically symbolizing e.g. the day, a group of people or something else.
It is up to the event organizer to create appropriate groupings for their specific event.

Each group in the event can be further subdivided into individual "slots". The slot symbolizes an individual
e.g. dance or course session.';

COMMENT ON COLUMN internal.event_slots.group_id IS 'Id of the event group this slot is a member of.';

CREATE TRIGGER internal_event_slots_moddatetime
  BEFORE UPDATE ON internal.event_slots
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

CREATE TABLE IF NOT EXISTS internal.event_slot_translations (
  id bigserial,
  slot_id uuid NOT NULL,
  language_code text COLLATE pg_catalog."default" NOT NULL,
  title text COLLATE pg_catalog."default" NOT NULL,
  description text COLLATE pg_catalog."default" NOT NULL DEFAULT ''::text,
  updated_at timestamp with time zone NOT NULL DEFAULT (now() AT TIME ZONE 'utc'::text),
  CONSTRAINT event_slot_translations_pkey PRIMARY KEY (id),
  CONSTRAINT event_slot_translations_slot_id_language_code_key UNIQUE (slot_id, language_code),
  CONSTRAINT event_slot_translations_language_code_fkey FOREIGN KEY (language_code) REFERENCES internal.languages (code) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE RESTRICT,
  CONSTRAINT event_slot_translations_slot_id_fkey FOREIGN KEY (slot_id) REFERENCES internal.event_slots (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS internal.event_slot_translations OWNER TO postgres;

ALTER TABLE IF EXISTS internal.event_slot_translations ENABLE ROW LEVEL SECURITY;

COMMENT ON TABLE internal.event_slot_translations IS 'Translated texts relating to a given event slot';

CREATE TRIGGER internal_event_slot_translations_moddatetime
  BEFORE UPDATE ON internal.event_slot_translations
  FOR EACH ROW
  EXECUTE FUNCTION extensions.moddatetime ('updated_at');

