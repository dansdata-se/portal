import { useRef, useState } from "react";
import { Meta, Story, Canvas } from "@storybook/addon-docs";
import LinkTo from "@storybook/addon-links/react";
import resolveConfig from "tailwindcss/resolveConfig";
import { Search, XCircle } from "react-feather";
import classNames from "classnames";

<Meta
  title="Styles/Components/Text Fields"
  argTypes={{
    parentBackground: {
      options: [
        "primary",
        "on-primary",
        "primary-container",
        "on-primary-container",
        "secondary",
        "on-secondary",
        "secondary-container",
        "on-secondary-container",
        "tertiary",
        "on-tertiary",
        "tertiary-container",
        "on-tertiary-container",
        "error",
        "on-error",
        "error-container",
        "on-error-container",
        "outline",
        "background",
        "on-background",
        "surface",
        "on-surface",
        "surface-variant",
        "on-surface-variant",
        "inverse-surface",
        "inverse-on-surface",
      ],
      control: {
        type: "select",
      },
    },
    type: {
      options: ["filled", "outlined"],
      control: {
        type: "radio",
      },
    },
    inputType: {
      options: ["text", "email", "textarea", "number", "password"],
      control: {
        type: "radio",
      },
    },
  }}
/>

# Text Fields

_Note: There exists a <LinkTo kind="components-textfield">helper component for text fields</LinkTo>_

There are two types of text fields: filled, and outlined.
These are based on the [guidelines from Material Design 3](https://m3.material.io/components/text-fields/overview).

The basic html structure of a textfield is

```html
<!--
Add the `data-disabled` attribute to display a disabled state.
Note that you should also add the `disabled` attribute to any
contained buttons and inputs/textareas to ensure they do not
receive any events!

Set the `data-error` attribute to `"true"` to show an error state
(e.g. invalid input).
-->
<div
  class="textfield texfield-${filled|outlined}"
  data-error="${true|false}"
  data-disabled="${true|false}"
>
  <!-- Optional: Leading text or icon. Wrap in button to make clickable. -->
  <button|svg|span class="leading">
    <svg />
  </button|svg|span>
  <div class="input-wrap">
    <!--
    A placeholder is required for styling to work as expected.
    If there should be no placeholder in this field, use an empty space.
    -->
    <input|textarea
      placeholder=" "
      type="${text|number|password}"
    />
    <!-- label must follow immediately _after_ input -->
    <label />
  </div>
  <!--
  Optional: Trailing text and/or icon.

  Multiple trailing elements are possible but discouraged.
  
  Wrap in button to make clickable.
  -->
  <button|svg|span class="trailing">
    <svg />
  </button|svg|span>
  <!--
  Optional.
  
  Caution:
  Supporting text will be displayed below the text field.
  The text field will _not_ grow to accommodate the extra height!
  -->
  <div class="supporting-wrap">
    <!-- Optional: Supporting text -->
    <span />
    <!--
    Optional: Character count (you must implement the logic yourself).
    
    Character count is expected to be the second `span` in the `supporting-wrap`.
    -->
    <span />
  </div>
</div>
```

<Canvas>
  <Story
    name="Text Fields"
    args={{
      parentBackground: "surface",
      type: "filled",
      inputType: "text",
      disabled: false,
      error: false,
      leadingIcon: false,
      leadingIconButton: false,
      trailingIcon: false,
      trailingIconButton: false,
      trailingText: "",
      label: "Label",
      supportingText:
        "Supporting text that is really long and requires multiple lines of text.",
      characterCount: true,
    }}
  >
    {({
      parentBackground,
      type,
      inputType,
      disabled,
      error,
      leadingIcon,
      leadingIconButton,
      trailingIcon,
      trailingIconButton,
      trailingText,
      label,
      supportingText,
      characterCount,
    }) => {
      const [maxLength, setMaxLength] = useState(60);
      const [currentLength, setCurrentLength] = useState(0);
      return (
        <div className={`p-6 pb-16 bg-${parentBackground}`}>
          <div
            className={`textfield textfield-${type}`}
            data-disabled={disabled}
            data-error={error}
          >
            {leadingIcon &&
              (leadingIconButton ? (
                <button
                  className="leading"
                  disabled={disabled}
                >
                  <Search />
                </button>
              ) : (
                <Search className="leading" />
              ))}
            <div className="input-wrap">
              {inputType == "textarea" ? (
                <textarea
                  id="mytextinput"
                  placeholder=" "
                  disabled={disabled}
                  {...(characterCount ? { maxlength: maxLength } : {})}
                  onInput={(e) =>
                    (e.target.style.height = `${e.target.scrollHeight}px`)
                  }
                  onChange={(e) => setCurrentLength(e.target.value.length)}
                />
              ) : (
                <input
                  id="mytextinput"
                  type={inputType}
                  placeholder=" "
                  disabled={disabled}
                  {...(characterCount ? { maxlength: maxLength } : {})}
                  onChange={(e) => setCurrentLength(e.target.value.length)}
                />
              )}
              <label for="mytextinput">{label}</label>
            </div>
            {trailingText && <span className="trailing">{trailingText}</span>}
            {trailingIcon &&
              (trailingIconButton ? (
                <button
                  className="trailing"
                  disabled={disabled}
                >
                  <XCircle />
                </button>
              ) : (
                <XCircle className="trailing" />
              ))}
            <div className="supporting-wrap">
              {supportingText && <span>{supportingText}</span>}
              {characterCount && <span>{`${currentLength}/${maxLength}`}</span>}
            </div>
          </div>
        </div>
      );
    }}
  </Story>
</Canvas>
